# è´ªå¿ƒç®—æ³•
## Acitivity Selection Problem
+ å‡è®¾æœ‰è®¸å¤šæ´»åŠ¨å’Œä¸€ä¸ªå¤§ç¤¼å ‚
+ æ¯ä¸ªæ´»åŠ¨éƒ½æœ‰å¼€å§‹æ—¶é—´å’Œç»“æŸæ—¶é—´
+ ä»»ä½•ä¸¤ä¸ªæ´»åŠ¨éƒ½ä¸èƒ½åœ¨å¤§ç¤¼å ‚ä¸­åŒæ—¶å‘ç”Ÿ
+ æ±‚å‡ºå¯ä¾›å®‰æ’çš„æœ€å¤§æ´»åŠ¨æ•°ç›®

### åˆ†æ²»æ³•
+ Define $S_i$ä¸ºåœ¨æ´»åŠ¨$a_i$ç»“æŸåå‘ç”Ÿçš„æ´»åŠ¨
+ Define $F_i$ä¸ºåœ¨æ´»åŠ¨$a_i$å¼€å§‹å‰ç»“æŸçš„æ´»åŠ¨
+ $OPT(S) = max_{1\geq i\geq n}\{OPT(F_i)+OPT(S_i)\}$
  + å¤æ‚åº¦ä»ç„¶å¾ˆé«˜
+ $OPT(S) = max_{1\geq i\geq n}\{1+OPT(S_i)\}$
+ **Observation: ä¸ºäº†ä½¿$OPT(S)$å°½å¯èƒ½å¤§ï¼Œéœ€è¦è®©$OPT(S_i)$å°½å¯èƒ½å¤§ï¼Œä¹Ÿå°±æ˜¯æŒ‘é€‰å‡ºçš„äº‹ä»¶$a_i$éœ€è¦å°½å¯èƒ½æ—©åœ°ç»“æŸã€‚**

### è´ªå¿ƒæ³•
+ ä¸æ–­æ‰¾åˆ°å½“å‰äº‹ä»¶ä¸­ç»“æŸæ—¶é—´æœ€æ—©çš„èŠ‚ç‚¹ï¼Œå°†è¯¥èŠ‚ç‚¹åŠ å…¥åˆ°è§£ä¸­ï¼Œå¹¶åœ¨åŸé›†åˆä¸­åˆ é™¤æ‰€æœ‰ä¸è¯¥èŠ‚ç‚¹å†²çªçš„èŠ‚ç‚¹
+ ä½¿ç”¨ä¸‹è¿°ç®—æ³•
  ```
  ActivitySelection(S):
  Sort S into increasing order of finish time
  SOL = {a1, }, a' = a1
  for (i=2 to n)
    if (ai.start_time > a'.finish_time)
        SOL.add(ai)
        a' = ai
  return SOL
  ```
+ ä¸‹é¢è¯æ˜è´ªå¿ƒæ³•çš„æ­£ç¡®æ€§

#### è¯æ˜è´ªå¿ƒæ³•çš„æ­£ç¡®æ€§
+ **ã€Lemma1ã€‘: let $a'$ be the earliest finishing activity in $S$, then $a'$ is in some optimal solution of the problem.**(greedy property)  
  ![](img/2019-11-25-02-33-49.png)
+ **ã€Lemma2ã€‘: let $a'$ be the earliest finishing activity in $S$, let $S'$ be the activities starting after $a'$, then $OPT(S')$$\cup\{a'\}$ is an optimal solution of the problem.**(optimal substructure)  
  ![](img/2019-11-25-02-34-24.png)
+ **ã€Theoremã€‘: The greedy algorithm is correct.**  
  ![](img/2019-11-25-02-34-45.png)
---
## è´ªå¿ƒç®—æ³•
### optimal substructure
+ åœ¨åŸé—®é¢˜çš„æœ€ä¼˜è§£ä¸­åŒ…å«çš„æŸä¸ªå­é—®é¢˜çš„å¯è¡Œè§£ä¸€å®šä¹Ÿæ˜¯è¿™ä¸ªå­é—®é¢˜çš„æœ€ä¼˜è§£
+ è®¾$OPT_{P(n)}$åŒ…å«å­é—®é¢˜$P(n\prime)$çš„å¯è¡Œè§£$SOL_{P(n\prime)}$
+ $SOL_{P(n\prime)}=OPT_{P(n\prime)}$

### greedy-choice property
+ åœ¨æ„é€ æœ€ä¼˜è§£çš„æ¯ä¸€æ­¥éª¤ä¸­ï¼Œéƒ½é€‰æ‹©åœ¨å½“å‰çŠ¶å†µä¸‹çœ‹èµ·æ¥æœ€å¥½çš„ç­–ç•¥ï¼Œè€Œä¸éœ€è¦è€ƒè™‘å­é—®é¢˜çš„æƒ…å†µå¦‚ä½•ã€‚ä¹Ÿå°±æ˜¯ä¸éœ€è¦å­é—®é¢˜çš„å›æº¯ç»“æœå°±ç›´æ¥ä½œå‡ºå½“å‰æ­¥éª¤çš„é€‰æ‹©ã€‚
+ éœ€è¦åšçš„å·¥ä½œå°±æ˜¯å…ˆæå‡ºä¸€ä¸ªç­–ç•¥ï¼Œç„¶åè¯æ˜è¯¥ç­–ç•¥ä½œå‡ºçš„é€‰æ‹©ä¼šå‡ºç°åœ¨æœ€åçš„æŸä¸ªæœ€ä¼˜è§£å½“ä¸­
+ å¦‚æœä¸€ä¸ªé—®é¢˜åªæ»¡è¶³æœ€ä¼˜å­ç»“æ„æ€§è´¨
  + åªéœ€è¦æ‰¾åˆ°iä½¿å¾—ièƒ½å¤Ÿ$maximize\{Utility(a_i+OPT_{P^i(n_i)})\}$
  + ç±»ä¼¼äºåˆ†æ²»çš„ç®—æ³•æ€è·¯ï¼Œéœ€è¦è®¡ç®—æ‰€æœ‰çš„$Utility(a_i+OPT_{P^i(n_i)})\}$
+ ä½†æ˜¯å¦‚æœä¸€ä¸ªé—®é¢˜æ—¢æ»¡è¶³æœ€ä¼˜å­ç»“æ„åˆæ»¡è¶³è´ªå¿ƒé€‰æ‹©æ€§è´¨
  + å¯ä»¥åŸºäºä¸€ä¸ªæ—¢å®šçš„ç­–ç•¥ç›´æ¥é€‰æ‹©å‡ºæ­£ç¡®çš„$a_i$ï¼Œæ— éœ€è®¡ç®—æ‰€æœ‰çš„$Utility(a_i+OPT_{P^i(n_i)})\}$
  + å› æ­¤å¯ä»¥å¤§å¹…å‡å°‘è¿è¡Œæ—¶é—´å¼€é”€
  + é—®é¢˜åœ¨äºæ­£ç¡®çš„è´ªå¿ƒé€‰æ‹©ç­–ç•¥å¾€å¾€å¾ˆéš¾æ‰¾åˆ°
+ **å› æ­¤**
  + **æœ€ä¼˜å­ç»“æ„æ€§è´¨å’Œè´ªå¿ƒé€‰æ‹©æ€§è´¨ä¿è¯äº†è´ªå¿ƒç®—æ³•çš„æ­£ç¡®æ€§**
  + **è´ªå¿ƒé€‰æ‹©æ€§è´¨ä¿è¯äº†è¿è¡Œæ—¶é—´çš„é«˜æ•ˆæ€§**
  + **æœ€ä¼˜å­ç»“æ„æ˜¯æ›´å®¹æ˜“æˆç«‹ã€æ›´å¹¿æ³›çš„æ€§è´¨ï¼Œä»»ä½•æ»¡è¶³æœ€ä¼˜å­ç»“æ„çš„é—®é¢˜éƒ½å¯ä»¥ä½¿ç”¨ç±»ä¼¼åˆ†æ²»æ³•çš„æ€è·¯å»è§£å†³ï¼Œè€Œä¸”è´ªå¿ƒé€‰æ‹©æ€§è´¨ä¹Ÿä¾èµ–äºæœ€ä¼˜å­ç»“æ„æ€§è´¨æ‰èƒ½æˆç«‹ã€‚ä½†å¹¶ä¸æ˜¯æ¯ä¸ªé—®é¢˜éƒ½æœ‰æ»¡è¶³è´ªå¿ƒé€‰æ‹©æ€§è´¨çš„ç­–ç•¥ï¼Œå› æ­¤è´ªå¿ƒç®—æ³•çš„å·¥ä½œé‡ä¸»è¦åœ¨äºï¼š*æ‰¾åˆ°è¿™æ ·ä¸€ç§æ»¡è¶³è´ªå¿ƒé€‰æ‹©æ€§è´¨çš„ç­–ç•¥*ã€‚**

---
## èƒŒåŒ…é—®é¢˜
+ ![](img/2019-11-25-02-36-45.png)

### è´ªå¿ƒ
+ è´ªå¿ƒç­–ç•¥ï¼šæ¯æ¬¡éƒ½æ‹¿æ€§ä»·æ¯”æœ€é«˜çš„ç‰©ä½“
+ **ã€Lemma1: greedy-choiceã€‘: let $a_m$ be a most efficient item, then in some optimal solution, at least $w_m^\prime=\min{w_m, W}$ pounds of $a_m$ are taken.**  
  ![](img/2019-11-25-02-36-12.png)
+ **ã€Lemma2: optimal substructureã€‘: ï¼Ÿï¼Ÿï¼Ÿ**
  ![](img/2019-11-25-02-36-29.png)

## 0-1èƒŒåŒ…é—®é¢˜
+ ![](img/2019-11-25-02-37-03.png)
### why greedy fail?
+ æœ€ä¼˜å­ç»“æ„æ€§è´¨æˆç«‹
+ è´ªå¿ƒé€‰æ‹©æ€§è´¨ä¸æˆç«‹
+ å› æ­¤å¯ä»¥ä½¿ç”¨åˆ†æ²»å’ŒåŠ¨æ€è§„åˆ’çš„æ€è·¯æ¥è§£å†³0-1èƒŒåŒ…é—®é¢˜

## æ•°æ®å‹ç¼©é—®é¢˜
+ é—®é¢˜æè¿°  
  ![](img/2019-11-25-02-37-31.png)
+ prefix-freeï¼šä»»æ„ä¸€ä¸ªç å­—éƒ½ä¸æ˜¯å¦å¤–ä¸€ä¸ªç å­—çš„ç¼–ç å‰ç¼€
+ ä½¿ç”¨å˜é•¿ç¼–ç å¯ä»¥æœ‰æ•ˆå‹ç¼©æ–‡ä»¶å¤§å°ã€‚ä»å¦ä¸€ç§è§’åº¦çœ‹ï¼Œå®šé•¿ç¼–ç ä¹Ÿæ˜¯prefix-freeçš„ï¼Œä½†æ˜¯å¹¶ä¸æ˜¯æœ€ä¼˜çš„å˜é•¿ç¼–ç æ–¹å¼
+ é—®é¢˜åœ¨äºï¼Œå¦‚ä½•ç”Ÿæˆæœ€ä¼˜å˜é•¿ç¼–ç 
### ç”Ÿæˆæœ€ä¼˜å˜é•¿ç¼–ç 
+ äº‹å®ä¸Šï¼Œå¯ä»¥ç”¨äºŒå‰æ ‘æ¥å¯è§†åŒ–ä¸€ç»„prefix-freeçš„ç¼–ç 
+ ![](img/2019-11-25-02-38-00.png)
+ æœ€ä¼˜çš„ç¼–ç æ–¹å¼ä¸€å®šæ˜¯è¢«å¯è§†åŒ–ä¸ºæ»¡äºŒå‰æ ‘çš„ç¼–ç æ–¹å¼
+ recursively merge the two least frequent chars to the top of the tree
+ å¯ä½¿ç”¨å°é¡¶å †æ¥å®ç°  
  ```
  Huffman(C):
  Build a priority queue Q based on frequency
  for (i=1 to n-1)
      Allocate new node z
      x = z.left = Q.ExtractMin()
      y = z.right = Q.ExtractMin()
      z.frequency = x.frequency + y.frequency
      Q.Insert(z)
  return Q.ExtractMin()
  ```
+ **ã€Lemma1: greedy choiceã€‘: Let $x$ and $y$ be two least frequent chars, then in some optimal code tree, $x$ and $y$ are siblings and have largesr depth**  
  ![](img/2019-11-25-02-39-18.png)
+ **ã€Lemma2: optimal substructureã€‘ï¼šLet ğ‘¥ and ğ‘¦ be two least frequent chars in ğ¶. Let ğ¶_ğ‘§=ğ¶âˆ’{ğ‘¥,ğ‘¦}+{ğ‘§} with ğ‘“_ğ‘§=ğ‘“_ğ‘¥+ğ‘“_ğ‘¦. Let ğ‘‡_ğ‘§ be an optimal code tree for ğ¶_ğ‘§. Let ğ‘‡ be a code tree obtained from ğ‘‡_ğ‘§ by replacing leaf node ğ‘§ with an internal node having ğ‘¥ and ğ‘¦ as children. Then, ğ‘‡ is an optimal code tree for ğ¶.**  
  ![](img/2019-11-25-02-39-53.png)

## Set Cover
+ é—®é¢˜æè¿°  
  ![](img/2019-11-25-02-22-46.png)
+ è´ªå¿ƒç­–ç•¥
  + æ¯æ¬¡éƒ½é€‰æ‹©èƒ½å¤Ÿè¦†ç›–æœ€å¤šçš„æœªè¢«è¦†ç›–çš„åŸå¸‚ï¼Œç›´åˆ°å®Œæˆå…¨éƒ¨è¦†ç›–
  + ![](img/2019-11-25-02-40-40.png)
  + è´ªå¿ƒç®—æ³•çš„è§£å¹¶ä¸æ˜¯æœ€ä¼˜è§£ï¼Œä½†åœ¨è¯¥é—®é¢˜ä¸­èƒ½å¤Ÿç»™å‡ºä¸€ä¸ªè¾ƒå¥½çš„è¿‘ä¼¼è§£
  + **ã€Theoremã€‘ï¼šSuppose thr optimal solution uses k sets, then the greedy strategy will use at most klgn sets.**  
    ![](img/2019-11-25-02-28-16.png)